(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{359:function(e,t,a){"use strict";a.r(t);var o=a(7),s=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("We are implementing a lock-based concurrency control scheme in this project. More specifically, the "),t("strong",[e._v("strict two phase locking protocol")]),e._v(".")]),e._v(" "),t("p",[e._v("The concept is not that hard. However, there are many implementation details we need to care about. Especially, sometimes we need to guess what is the test code wants.")]),e._v(" "),t("p",[e._v("You need to read the source code carefully. The instruction of this project is kind vague, or even wrong.")]),e._v(" "),t("h2",{attrs:{id:"task-1-lock-manager"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#task-1-lock-manager"}},[e._v("#")]),e._v(" Task 1 - Lock Manager")]),e._v(" "),t("p",[e._v("Read "),t("code",[e._v("transaction.h")]),e._v(", "),t("code",[e._v("transaction_manager.h")]),e._v(", and "),t("code",[e._v("log_manager.h")]),e._v(" to learn the APIs first.")]),e._v(" "),t("p",[e._v("The log manager only communicates with transactions and the transaction manager. As the textbook says, the log manager tracks all the lock requests for different tuples; a transaction tracks all the locks it holds for different tuples.")]),e._v(" "),t("p",[e._v("All the works are around the management of the hash table in the "),t("code",[e._v("log_manager")]),e._v(" and the two sets that track locks in "),t("code",[e._v("transaction")]),e._v(". We only need to implement the basic logic structure of each API in this task because we will modify them in the following tasks.")]),e._v(" "),t("h2",{attrs:{id:"task-2-deadlock-prevention"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#task-2-deadlock-prevention"}},[e._v("#")]),e._v(" Task 2 - Deadlock Prevention")]),e._v(" "),t("p",[e._v("We use "),t("strong",[e._v("wound-wait")]),e._v(' here, which means, when requesting a lock on a data item, the "younger" transactions wait for the "older" transactions, while the "older" transactions kill the "younger" transactions.')]),e._v(" "),t("p",[e._v("Because the "),t("code",[e._v("log_manager")]),e._v(" and "),t("code",[e._v("transaction")]),e._v(" track the lock requests for each tuple and each transaction, this part of work is")]),e._v(" "),t("h2",{attrs:{id:"task-3-concurrency-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#task-3-concurrency-control"}},[e._v("#")]),e._v(" Task 3 Concurrency Control")]),e._v(" "),t("p",[e._v("The instruction and code are inconsistent. The instruction asks us to maintain the write sets in transactions. However, the table write sets have already been handled by the APIs in "),t("code",[e._v("table_heap.cpp")]),e._v(".  As a result, actually, we do not need to maintain the tuple write sets by ourself.")]),e._v(" "),t("p",[e._v("Each transaction can execute several queries. We should consider this and modify our lock manager. For example, what should we do if a transaction inserts some tuples, then read them?")]),e._v(" "),t("p",[e._v("To achieve different isolation level with strict 2PL protocol, we need to use these locks properly in different executor. According to the lecture slides, we should:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Serializable")]),e._v(": Obtain all locks first; ;plus index locks, plus strict 2PL.")]),e._v(" "),t("li",[t("strong",[e._v("Repeatable Reads")]),e._v(": Same as above, but no index locks.")]),e._v(" "),t("li",[t("strong",[e._v("Read Committed")]),e._v(": Same as above, but share locks are released immediately.")]),e._v(" "),t("li",[t("strong",[e._v("Read Uncommitted")]),e._v(": Same as above but allows dirty reads (no share locks).")])]),e._v(" "),t("p",[e._v("Some exceptions that are thrown from the lock manager cannot be fetched by the test code. So, letting the caller of the lock manager to handle lock fails is a better choice. This costed me few hours to debug..")]),e._v(" "),t("h2",{attrs:{id:"result"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#result"}},[e._v("#")]),e._v(" Result")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/z1ggy-o/static_resources/main/img/cmu15445-project03-grades.png",alt:"image.png"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);