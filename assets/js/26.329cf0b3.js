(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{340:function(e,t,a){"use strict";a.r(t);var o=a(7),i=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"motivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),t("p",[e._v("We are moving to the many-core architecture era, however, many design of database systems are still based on optimizing of single-threaded performance.")]),e._v(" "),t("p",[e._v("To understand how to design high performance DBMS for the future many-core architecture to achieve high scalability, addressing bottlenecks in the system is necessary.")]),e._v(" "),t("p",[e._v("This paper focus on concurrency control schemes.\n(spoiler:  the [following research]([[@An empirical evaluation of in-memory multi-version concurrency control]]) of [[Andrew Pavlo]] found out concurrency control schemes are not the most important component that affect the scalability of main memory DBMS on many-core environment )")]),e._v(" "),t("h2",{attrs:{id:"contribution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#contribution"}},[e._v("#")]),e._v(" Contribution")]),e._v(" "),t("ul",[t("li",[e._v("Evaluation of the scalability of seven commonly used concurrency control schemes (OLTP, in-memory DBMS)")]),e._v(" "),t("li",[e._v("Evaluation is processed on a simulated machine with 1000 cores (actually is a cluster of 22 real machines)")])]),e._v(" "),t("h2",{attrs:{id:"solution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solution"}},[e._v("#")]),e._v(" Solution")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("This is evaluation paper, thus there is no solutions but evaluation analyses.")])]),e._v(" "),t("li",[t("p",[e._v("All concurrency control schemes fail to scale to a large number of cores. The bottlenecks are:")]),e._v(" "),t("ol",[t("li",[e._v("lock thrashing")]),e._v(" "),t("li",[e._v("preemptive aborts")]),e._v(" "),t("li",[e._v("deadlocks")]),e._v(" "),t("li",[e._v("timestamp allocation")]),e._v(" "),t("li",[e._v("memory-to-memory copying")])])]),e._v(" "),t("li",[t("p",[e._v('Lock thrashing happens in any waiting-based algorithm. Using the "non-waiting" can alleviate this problem, however, we will have more aborting.')])]),e._v(" "),t("li",[t("p",[e._v("In high contention workloads, a non-waiting deadlock prevention scheme is better than deadlock detection. (Restart is fast in main memory DBMS)")])]),e._v(" "),t("li",[t("p",[e._v("Memory allocation (includes timestamp allocation) is usually managed by a centric data structure, which becomes the bottleneck. Avoiding shared, centric data structure is important to achieve higher scalability.")])]),e._v(" "),t("li",[t("p",[e._v("Add new hardware to offload some tasks (e.g., memory copying) from CPU is a feasible way to improve the scalability")])])]),e._v(" "),t("h2",{attrs:{id:"evaluation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#evaluation"}},[e._v("#")]),e._v(" Evaluation")]),e._v(" "),t("ul",[t("li",[e._v("The evaluation platform is based on a CPU simulator, Graphite (from MIT).")]),e._v(" "),t("li",[e._v("The authors implemented a lightweight main memory DBMS only for this testing.")]),e._v(" "),t("li",[e._v("Workloads are YCSB and TPC-C")])]),e._v(" "),t("h2",{attrs:{id:"main-finding-of-the-paper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#main-finding-of-the-paper"}},[e._v("#")]),e._v(" Main finding of the paper")]),e._v(" "),t("ul",[t("li",[e._v("Like other systems, to improve the scalability, how to avoid shared data is the key.")]),e._v(" "),t("li",[e._v('"Measure, Then Build", and a thorough measurement is always needed. This paper is good enough on analyzing concurrency control schemes, however, the following research revels that this is not the most important part...')])])])}),[],!1,null,null,null);t.default=i.exports}}]);